WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* ~ "\n" }

rule_start = {"A " | "An "}
label = @{ (!(". " ~ rule_start)  ~ ANY)+ ~ ". " }

object_selector = @{ "**" ~ identifier ~ "**" }
selector = @{ identifier }

condition_operator = {"and" | "or"}

outcome = @{ (!("if" | ".") ~ ANY)+ }
rule_header = { label? ~ rule_start ~ object_selector }
rule_set = { SOI ~ (COMMENT | rule)* ~ EOI }
rule = {
    rule_header ~ rule_outcome ~
    "if" ~ condition ~ (condition_operator ~ condition)* ~ "."
}
rule_outcome = {
  outcome_verb? ~ outcome
}
outcome_verb = {
  "gets" | "passes" | "is" | "has" | "receives" | "qualifies for" | "meets" | "satisfies"
}

label_name = @{(ASCII_ALPHANUMERIC | "_" | "-")+}
label_predicate = _{ "is valid" | "is approved" | "has passed" }
label_reference = { "ยง" ~ label_name ~ label_predicate? }

condition = {
    property_condition |
    label_reference |
    rule_reference
}

// Property condition now handles chained access
property_condition = {
    ("the")? ~ property_access ~ predicate
}

// Property access can be chained: __prop__ of __prop__ of **obj**
property_access = {
    property ~ ("of" ~ ("the")? ~ property)* ~ "of" ~ ("the")? ~ object_selector
}

rule_reference = { "the"? ~ object_selector ~ reference_name }
reference_name = @{ (!("." | "and" | "or" | "\n") ~ ANY)+ }

predicate = {
    comparison_operator ~ (property_access | value) |
    list_operator ~ (property_access | list_value)
}

list_operator = {
    "is in" |
    "is not in"
}

comparison_operator = {
    "is greater than or equal to" |
    "is less than or equal to" |
    "is equal to" |
    "is not equal to" |
    "is the same as" |
    "is not the same as" |
    "is later than" |
    "is earlier than" |
    "is greater than" |
    "is less than" |
    "contains"
}

list_value = { "[" ~ value ~ ("," ~ value)* ~ "]" }
value = { number | string_literal | date_literal | boolean }

rule_name = @{(!(". " | " and " | ".") ~ ANY)+}
property = @{ "__" ~ property_name ~ "__" }
property_name = @{ (!("__") ~ ANY)+ }
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
string_literal = @{ "\"" ~ (!("\"") ~ ANY)* ~ "\"" | identifier }
number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
date_format = @{ ASCII_DIGIT{4} ~ "-" ~ ASCII_DIGIT{2} ~ "-" ~ ASCII_DIGIT{2} }
date_literal = @{
  "date(" ~ date_format ~ ")" |
  date_format
}
boolean = { "true" | "false" }